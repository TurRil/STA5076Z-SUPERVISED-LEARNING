---
title: "R Notebook"
output: html_notebook
---

OSTAND005 Oosthuizen,	Andries	Cornelius 

0 2 4 6 7 

```{r read-data, echo=FALSE, eval=TRUE}
FILE.TRAIN <- "mnist_data/mnist_train.csv"
FILE.TEST <- "mnist_data/mnist_test.csv"

training.raw <- read.table(FILE.TRAIN, header = T, dec = ".", sep =",")
test.raw <- read.table(FILE.TEST, header = T, dec = ".", sep =",")
```

```{r}

myset <- c(0,2,4,6,7)
training <- list()

for(i in 1:length(myset)) { 
  training[[i]] = subset(training.raw, label==myset[i])
}
```

```{r}
rotate <- function(m) { t(apply(m, 1, rev)) }

print8 <- function(n = 1) {
  
  par(mfrow=c(2,4))
  for(i in 1:8) {
   
    img <- rotate(matrix(unlist(training[[n]][i,-1]), nrow = 28))
    image(img, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1)
  }
}

print8(1)
```


```{r}
print8(2)
```

```{r}
print8(3)
```

```{r}
print8(4)
```
```{r}
print8(5)
```
```{r}

par(mfrow=c(4,3),pty='s',mar=c(1,1,1,1),xaxt='n',yaxt='n')
all_img<-array(dim=c(10,28*28))

digits = c()

for(di in 0:9)
{
  all_img[di+1,]<-apply(training.raw[training.raw[,1]==di,-1],2,sum)
  all_img[di+1,]<-all_img[di+1,]/max(all_img[di+1,])*255
   
  z<-array(all_img[di+1,],dim=c(28,28))
  z<-z[,28:1] ##right side up
  image(1:28,1:28,z,col = gray((128-(0:128))/128),main=di)
  digits <- rbind(digits, as.vector(z))
}
```

#par(mfrow=c(1,5), pty='s', mar=c(1,1,1,1), xaxt='n', yaxt='n')

#all_img <- array(dim=c(10,28*28))

#digits = c(14*14)

#for(di in 1:length(myset))
#{
  digits <- apply(train_14[, -1], 2, sum)
  digits <- all_img[di+1,]/max(all_img[di+1,])*255
   
  z <- array(all_img[di+1,],dim=c(14,14))
  #x <- subset(as.vector(z))
  #z <- z[,14:1] ##right side up
  image(1:14,1:14, z, col = gray((128-(0:128))/128), main=myset[di])
  

```{r}

calcVerticalSymmetry <- function(data, rowNumber) {
    digit <- matrix(as.numeric(data[rowNumber, ]), nrow = 28)
    digit <- digit[, nrow(digit):1]  # reverse matrix rows (flip images upside right)
    
    rowSumDiffs <- rep(0, 28)
    for (i in 1:28) {                     # loop through each row
        hDiffs <- 0
        for (j in 1:(ncol(digit)/2)) {    # loop through half of the columns
            hDiffs = hDiffs + 1 / (abs(digit[i, j] - digit[i, ncol(digit) - j + 1]) + 1)
        }
        rowSumDiffs[i] <- hDiffs
    }
    return(rowSumDiffs)  # summarize each row's 'symmetry'
}

calcHorizontalSymmetry <- function(data, rowNumber) {
    digit <- matrix(as.numeric(data[rowNumber, ]), nrow = 28)
    digit <- digit[, nrow(digit):1]  # reverse matrix rows (flip images upside right)
    
    colSumDiffs <- rep(0, 28)
    for (j in 1:28) {                     # loop through each column
        vDiffs <- 0
        for (i in 1:(nrow(digit)/2)) {    # loop through half of the rows
            vDiffs = vDiffs + 1 / (abs(digit[i, j] - digit[nrow(digit) - i + 1, j]) + 1)
        }
        colSumDiffs[j] <- vDiffs
    }
    return(colSumDiffs)  # summarize each cols' 'symmetry'
}

for(di in 0:9) {

  v <- calcVerticalSymmetry(digits, di+1)
  h <- calcHorizontalSymmetry(digits, di+1)
  
  plot(v, main=di, lty="p", col = "#")
  points(h, col="red", pch=19)
}
```


```{r}
bitsToInt<-function(x) {
    packBits(rev(c(rep(FALSE, 32-length(x)%%32), as.logical(x))), "integer")
}

reduce <- function(m, i, j) {
  val = (m[i,j] + m[i,j+1] + m[i+1,j] + m[i+1,j+1])/4

  return (val)
}

smaller <- function(t, v=2) {
  vv <- 28/v
  mat <- matrix(rep(0, vv * vv), nrow = vv)
  for (i in seq(1, 28, by = v)) {
     for (j in seq(1,28, by=v)) {
       mat[ (i+1)/v, (j+1)/v] = reduce(t, i, j)
     }
  }
  
  return(mat)
}

t1 <- rotate(matrix(unlist(training[[1]][1,-1]), nrow = 28))
t2 <- rotate(matrix(unlist(training[[2]][1,-1]), nrow = 28))
t3 <- rotate(matrix(unlist(training[[3]][1,-1]), nrow = 28))
t4 <- rotate(matrix(unlist(training[[4]][4,-1]), nrow = 28))
t5 <- rotate(matrix(unlist(training[[5]][1,-1]), nrow = 28))

par(mfrow=c(2,5))
image(t1, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1)
image(t1, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1)
image(t1, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1)
image(t1, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1)
image(t1, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1)

ss <- seq(from = 1, to = 0.25, length.out = 5)
for(i in 1:length(ss)) {
  s <- rescale(t1, ss[i], triangleKernel())
  image(s, col = gray(128:0/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(s)))
}
```

```{r}
sm1 <- smaller(t1)
sm2 <- smaller(t2)
sm3 <- smaller(t3)
sm4 <- smaller(t4)
sm5 <- smaller(t5)

#sm2 <- rescale(t1, 0.5, mnKernel())
#sm3 <- rescale(t1, 0.25, mnKernel())

par(mfrow=c(1,2))

s <- rescale(t1, 0.5, triangleKernel())
image(s, col = gray(128:0/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(s)))
  
image(sm1, col = gray(128:0/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(sm1)))
#image(sm2, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(sm2)))
#image(sm3, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(sm3)))
#image(sm4, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(sm4)))
#image(sm5, col = gray((128-(0:128))/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(sm5)))
```


```{r}
k <- shapeKernel(c(2,2), type="box")
fc <- components(t1, k)



par(mfrow=c(1,3))
image(fc, col = gray(128:0/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(fc)))
image(components(s1, k), col = gray(128:0/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(s1)))
image(components(s2, k), col = gray(128:0/128), xaxt='n', yaxt='n', asp=1, main=paste(dim(s2)))
#display(fc, col=rainbow(max(fc,na.rm=TRUE)))
```


```{r}
mat = smaller(t1)

c = 1
v1 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 2
v2 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 3
v3 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 4
v4 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 5
v5 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 6
v6 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 7
v7 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 8
v8 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 9
v9 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 10
v10 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 11
v11 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 12
v12 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 13
v13 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

c = 14
v14 <- c(bitsToInt(sm1[c,]), bitsToInt(sm2[c,]), bitsToInt(sm3[c,]), bitsToInt(sm4[c,]), bitsToInt(sm5[c,]))

df <- data.frame(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)

str(df)
```
```{r}

#library(MASS)
#lm(label ~ pix1_1 + pix1_2 + pix1_3 + pix1_2, data = training_0) 

library("mmand")

k <- shapeKernel(c(3,3), type="box")

display(t1)
display(skeletonise(medianFilter(t1, k), k, method="lantuejoul"), col="red", add=TRUE)

#display(sm1); 
#display(skeletonise(medianFilter(sm1, k1),k2,method="lantuejoul"), col="red", add=TRUE)
```


```{r}
#wss <- (nrow(df)-1)*sum(apply(df,2,var))
#for (i in 2:4) wss[i] <- sum(kmeans(df, centers=i)$withinss)

#plot(1:4, wss, type="b", xlab="Number of Clusters", ylab="Within groups sum of squares")

d <- dist(df, method = "euclidean") # distance matrix

fit <- hclust(d, method="ward.D") 
plot(fit) # display dendogram

groups <- cutree(fit, k=5) # cut tree into 5 clusters
```

